#!/usr/bin/env python3

import argparse
import json
import os
import sys
from threading import Lock

if __name__ == '__main__':  # noqa
    pkg_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))  # noqa
    sys.path.insert(0, pkg_root)  # noqa

from hca.util.pool import ThreadPool

from dcp_diag.finders import Finder
from dcp_diag.api_agents import DataStoreAgent


class AnalyzeSubmission:

    """
    # Start with Submission ID, then check:
    # ✔︎    Primary bundles (known by Ingest)
    # ✔︎    Primary bundles in DSS/AWS (direct access)
    # ✔︎    Primary bundles in DSS/GCP (direct access)
    # ✔︎    Primary bundles searchable in DSS/AWS using Project ID
    # ✔︎    Primary bundles searchable in DSS/GCP using Project ID
    # ✔    Secondary bundles searchable in DSS/AWS using files.analysis_process_json.input_bundles
    # ✔    Secondary bundles searchable in DSS/GCP using files.analysis_process_json.input_bundles
    # todo  Secondary bundles searchable in DSS/AWS using Project ID
    # todo  Secondary bundles searchable in DSS/GCP using Project ID

    # Cache results so we can reload and update later?
    """

    class AnalysisState:

        def __init__(self):
            self.bundle_map = {}
            self.lock = Lock()

        def save(self, filename):
            output(f"\nSaving results in {filename}...")
            with open(filename, 'w') as fp:
                fp.write(json.dumps(self.bundle_map, indent=4))
            output("done\n")

    class DSSBundlePresenceChecker:

        def __init__(self, deployment, state, options):
            self.deployment = deployment
            self.state = state
            self.options = options

            self.primary_bundle_count = len([k for (k, v) in self.state.bundle_map.items() if v['type'] == 'primary'])
            self.checked_bundles = {'aws': 0, 'gcp': 0}

            self.check_for_bundles()
            self.print_results()

        def check_for_bundles(self):
            print("\nChecking bundles are in AWS & GCP DSS...")
            pool = ThreadPool(self.options.jobs)
            for bundle_uuid in self.state.bundle_map.keys():
                self.state.bundle_map[bundle_uuid]['dss_presence'] = {}
                for replica in ['aws', 'gcp']:
                    pool.add_task(self._check_bundle_manifest_exists, bundle_uuid, replica)
            pool.wait_for_completion()
            print("\ndone.")

        def _check_bundle_manifest_exists(self, bundle_uuid, replica):
            dss = DataStoreAgent(self.deployment)
            try:
                dss.bundle_manifest(bundle_uuid, replica)
                with self.state.lock:
                    self.state.bundle_map[bundle_uuid][replica]['dss_presence'] = True
            except AssertionError as e:
                with self.state.lock:
                    self.state.bundle_map[bundle_uuid][replica]['dss_presence'] = False
                    print(f"\rbundle {bundle_uuid} is missing from {replica.upper()}")
            self.checked_bundles[replica] += 1
            self._print_progress()

        def _print_progress(self):
            if sys.stdout.isatty():
                output(f"\r\tChecking for bundle manifests: "
                       f"AWS: {self.checked_bundles['aws']}/{self.primary_bundle_count}"
                       f" GCP: {self.checked_bundles['gcp']}/{self.primary_bundle_count}")

        def print_results(self):
            for replica in ['aws', 'gcp']:
                bundle_replica_presence = {k: v[replica]['dss_presence'] for (k, v) in self.state.bundle_map.items()}
                present_bundles = [k for (k, v) in bundle_replica_presence.items() if v]
                absent_bundles = [k for (k, v) in bundle_replica_presence.items() if not v]
                print(f"{len(present_bundles)} bundle are present in {replica.upper()}")
                if len(present_bundles) > 0:
                    if self.options.verbose:
                        for uuid in present_bundles:
                            print(f"\t{uuid}")
                if len(absent_bundles) > 0:
                    print(f"{len(absent_bundles)} bundle is absent from {replica.upper()}")
                    for uuid in absent_bundles:
                        print(f"\t{uuid}")

    class SearchDSSbyProjectUUID:

        def __init__(self, project_uuid, deployment, state, options):
            self.deployment = deployment
            self.state = state
            self.options = options

            self.search_for_bundles(project_uuid)
            for replica in ['aws', 'gcp']:
                self.print_results(replica)

        def search_for_bundles(self, project_uuid):
            # TODO: consider the possibility the search returns MORE bundles than Ingest knows about
            output("\nSearching DSS for bundles with this project UUID...")
            dss = DataStoreAgent(self.deployment)
            query = {
                "query": {
                    "bool": {
                        "must": [
                            {
                                "match": {
                                    "files.project_json.provenance.document_id": project_uuid
                                }
                            }
                        ],
                        "must_not": [
                            {
                                "match": {
                                    "files.analysis_process_json.process_type.text": "analysis"
                                }
                            }
                        ]
                    }
                }
            }

            for replica in ['aws', 'gcp']:
                results = dss.search(query, replica=replica)
                for result in results:
                    with self.state.lock:
                        bundle_components = result['bundle_fqid'].split('.', 1)
                        bundle_uuid = bundle_components[0]
                        self.state.bundle_map[bundle_uuid][replica]['in_dss_project_search'] = True
            output("done.\n")

        def print_results(self, replica):
            primary_bundles_indexed_by_project = [
                k for (k, v) in self.state.bundle_map.items() if v[replica].get('in_dss_project_search')]
            print(f"In {replica.upper()} DSS, {len(primary_bundles_indexed_by_project)} are indexed by project")
            if self.options.verbose:
                for bundle_uuid in primary_bundles_indexed_by_project:
                    print(f"\t{bundle_uuid}")

            primary_bundles_not_indexed_by_project = [
                k for (k, v) in self.state.bundle_map.items() if not v[replica].get('in_dss_project_search')]
            if len(primary_bundles_not_indexed_by_project) > 0:
                print(
                    f"In {replica.upper()} DSS, "
                    "{len(primary_bundles_not_indexed_by_project)} are NOT indexed by project")
                for bundle_uuid in primary_bundles_not_indexed_by_project:
                    print(f"\t{bundle_uuid}")

    class SearchDSSforSecondaryBundles:

        def __init__(self, deployment, state, options):
            self.deployment = deployment
            self.state = state
            self.options = options

            self.search_for_bundles()
            self.print_results('aws')
            self.print_results('gcp')

        def search_for_bundles(self):
            output("\nSearching AWS & GCP DSS for secondary bundles...")
            pool = ThreadPool(self.options.jobs)
            for pri_uuid in self.state.bundle_map.keys():
                self.state.bundle_map[pri_uuid]['results_bundles'] = {}
                for replica in ['aws', 'gcp']:
                    self.state.bundle_map[pri_uuid][replica]['results_bundles'] = []
                    pool.add_task(self._find_secondary_bundles_for_primary_bundle, pri_uuid, replica)
            pool.wait_for_completion()
            output("...done.\n")

        def _find_secondary_bundles_for_primary_bundle(self, pri_uuid, replica):
            dss = DataStoreAgent(self.deployment)
            query = {
                "query": {
                    "match": {
                        "files.analysis_process_json.input_bundles": pri_uuid
                    }
                }
            }
            results = dss.search(query, replica=replica)
            output(f"{len(results)}")
            if len(results) > 0:
                with self.state.lock:
                    for result in results:
                        results_bundle_uuid = result['bundle_fqid'].split('.')[0]
                        self.state.bundle_map[pri_uuid][replica]['results_bundles'].append(results_bundle_uuid)

        def print_results(self, replica):
            replica_results = {k: v[replica]['results_bundles'] for (k, v) in self.state.bundle_map.items()}

            i = 0
            while len(replica_results) > 0:
                pri_sec = {k: v for (k, v) in replica_results.items() if len(v) == i}
                count = len(pri_sec)
                if count > 0:
                    print(f"In {replica.upper()} there are {count} primary bundles with {i} results bundles")
                    if self.options.verbose or i != 1:
                        for pri, sec in pri_sec.items():
                            print(f"\tprimary: {pri} secondary: {sec}")

                for key in pri_sec.keys():
                    del replica_results[key]

                i += 1

    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-d', '--deployment', help="search this deployment")
        parser.add_argument('submission_id')
        parser.add_argument('-v', '--verbose', action='store_true', help="provide lots of detail in output")
        parser.add_argument('-j', '--jobs', type=int, default=10, help="concurrently level to use (default: 10)")
        parser.add_argument('-s', '--save', action='store_true',
                            help="save state in <submission_id>.json file for future use")

        args = parser.parse_args()
        self.verbose = args.verbose
        self.concurrency = args.jobs
        self.state = self.AnalysisState()

        self.deployment = self._choose_deployment(args)
        print(f"Using deployment: {self.deployment}")

        subm = self._retreive_submission(args.submission_id)

        project = subm.project()
        print(f"Project UUID: {project.uuid}")

        self._get_primary_bundle_list_from_ingest(subm)
        self.DSSBundlePresenceChecker(self.deployment, self.state, options=args)
        self.SearchDSSbyProjectUUID(project_uuid=project.uuid, deployment=self.deployment,
                                    state=self.state, options=args)
        self.SearchDSSforSecondaryBundles(deployment=self.deployment, state=self.state, options=args)
        if args.save:
            self.state.save(filename=f"{args.submission_id}.json")

    def _choose_deployment(self, args):
        if 'deployment' in args and args.deployment:
            return args.deployment
        elif 'DEPLOYMENT_STAGE' in os.environ:
            deployment = os.environ['DEPLOYMENT_STAGE']
            answer = input(f"Use deployment {deployment}? (y/n): ")
            if answer is 'y':
                return deployment
            else:
                exit(1)
        else:
            print("You must supply the --deployment argument or set environment variable DEPLOYMENT_STAGE")
            sys.exit(1)

    def _retreive_submission(self, submission_id):
        output("\nRetreiving submission...")
        finder = Finder.factory(finder_name="ingest", deployment=self.deployment)
        submission = finder.find(f"subm_id={submission_id}")
        output("done.\n")
        print(submission)
        return submission

    def _get_primary_bundle_list_from_ingest(self, subm):
        output("\nRetrieving submission's primary bundle list...")

        for pri_uuid in subm.bundles():
            self.state.bundle_map[pri_uuid] = {
                'type': 'primary',
                'aws': {},
                'gcp': {}
            }
        output("done.\n")

        output(f"Ingest created {len(self.state.bundle_map)} bundles.\n")
        if self.verbose:
            for bundle_uuid in sorted(self.state.bundle_map.keys()):
                print(f"\t{bundle_uuid}")


def output(message, newline_before=False, newline_after=False):
    if newline_before:
        sys.stdout.write("\n")
    sys.stdout.write(message)
    if newline_after:
        sys.stdout.write("\n")
    sys.stdout.flush()


AnalyzeSubmission()
